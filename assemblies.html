<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Assemblies - LITCoder</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/tutorials.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="index.html" class="nav-logo">LITCoder</a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="tutorials.html">Tutorials</a>
                <a href="https://arxiv.org/abs/2509.09152" target="_blank">Paper</a>
                <a href="https://github.com/GT-LIT-Lab/litcoder_core" target="_blank">GitHub</a>
            </div>
        </nav>

        <header class="tutorial-header">
            <h1>Understanding Assemblies in LITcoder</h1>
            <p>An <strong>Assembly</strong> is the core data structure in LITcoder that organizes and manages brain imaging data, stimuli, and metadata for encoding model training. It's the foundation that everything else builds upon.</p>
        </header>

        <section class="tutorial-section">
            <h2>What is an Assembly?</h2>
            <p>An assembly is a structured container that holds all the data needed to train encoding models:</p>
            <ul>
                <li><strong>Brain Data</strong>: Recordings aligned with stimuli</li>
                <li><strong>Stimuli</strong>: Text or audio stimuli presented during the experiment</li>
                <li><strong>Timing Information</strong>: Precise timing of when each stimulus was presented</li>
                <li><strong>Split Indices</strong>: Maps each word/stimulus to its corresponding TR (time repetition)</li>
                <li><strong>Metadata</strong>: Story names, subject information, and experimental parameters</li>
            </ul>
            <p>Think of an assembly as a well-organized database that contains everything needed to train a brain encoding model.</p>
        </section>

        <section class="tutorial-section">
            <h2>Assembly Structure</h2>
            <p>An assembly contains several key components:</p>
            <p><strong>Stories</strong>: List of story/run names<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Each story represents a continuous experimental session (e.g., listening to a story)</p>
            <p><strong>Story Data</strong>: Dictionary mapping story names to their data<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Contains brain data, stimuli, timing, and metadata for each story</p>
            <p><strong>Timing Information</strong>:
            <br>&nbsp;&nbsp;&nbsp;&nbsp; - <code>tr_times</code>: When each TR (time repetition) occurred
            <br>&nbsp;&nbsp;&nbsp;&nbsp; - <code>data_times</code>: Precise timing for each data point (word-level)
            <br>&nbsp;&nbsp;&nbsp;&nbsp; - <code>split_indices</code>: Maps each word to its corresponding TR</p>
            <p><strong>Brain Data</strong>:
            <br>&nbsp;&nbsp;&nbsp;&nbsp; - Preprocessed fMRI data aligned with stimuli
            <br>&nbsp;&nbsp;&nbsp;&nbsp; - Shape: (n_timepoints, n_voxels/vertices)</p>
        </section>

        <section class="tutorial-section">
            <h2>Working with Assemblies</h2>
            <p>Let's explore how to work with assemblies using the LeBel assembly:</p>
            <pre class="code-block"><code class="language-python">from encoding.assembly.assembly_loader import load_assembly

# Load the pre-packaged LeBel assembly
assembly = load_assembly("assembly_lebel_uts03.pkl")

# Basic information
print(f"Assembly shape: {assembly.shape}")
print(f"Stories: {assembly.stories}")
print(f"Validation method: {assembly.get_validation_method()}")</code></pre>
        </section>

        <section class="tutorial-section">
            <h2>Key Assembly Methods</h2>
            <p>Here are the most important methods for working with assemblies:</p>
            <p><strong>Data Access</strong>:</p>
            <ul>
                <li><code>get_stimuli()</code>: Get text stimuli for each story</li>
                <li><code>get_brain_data()</code>: Get brain data for each story</li>
                <li><code>get_split_indices()</code>: Get word-to-TR mapping</li>
                <li><code>get_tr_times()</code>: Get TR timing information</li>
                <li><code>get_data_times()</code>: Get precise word-level timing</li>
            </ul>
            <p><strong>Story-Specific Data</strong>:</p>
            <ul>
                <li><code>get_temporal_baseline(story_name)</code>: Get temporal baseline features</li>
                <li><code>get_audio_path()</code>: Get audio file paths (for speech models)</li>
                <li><code>get_words()</code>: Get individual words for each story</li>
                <li><code>get_word_rates()</code>: Get pre-computed word rates</li>
            </ul>
            <p><strong>Metadata</strong>:</p>
            <ul>
                <li><code>get_validation_method()</code>: Get validation strategy ("inner" or "outer")</li>
                <li><code>stories</code>: List of story names</li>
                <li><code>story_data</code>: Dictionary of story-specific data</li>
            </ul>
        </section>

        <section class="tutorial-section">
            <h2>Exploring Assembly Contents</h2>
            <p>Let's examine what's inside an assembly:</p>
            <pre class="code-block"><code class="language-python"># Load assembly
assembly = load_assembly("assembly_lebel_uts03.pkl")

# Basic information
print("=== Assembly Overview ===")
print(f"Total presentations: {assembly.shape[0]}")
print(f"Number of voxels/vertices: {assembly.shape[1]}")
print(f"Stories: {assembly.stories}")
print(f"Validation method: {assembly.get_validation_method()}")

# Explore each story
print("\n=== Story Details ===")
for story in assembly.stories:
    story_data = assembly.story_data[story]
    print(f"\nStory: {story}")
    print(f"  Brain data shape: {story_data.brain_data.shape}")
    print(f"  Number of stimuli: {len(story_data.stimuli)}")
    print(f"  Split indices: {len(story_data.split_indices)} words")
    print(f"  TR times: {len(story_data.tr_times)} TRs")
    print(f"  Data times: {len(story_data.data_times)} words")

    # Show first few stimuli
    print(f"  First 3 stimuli: {story_data.stimuli[:3]}")

    # Show split indices (these map words to TRs)
    print(f"  First 10 split indices: {story_data.split_indices[:10]}")
    print(f"  Last 10 split indices: {story_data.split_indices[-10:]}")</code></pre>
        </section>

        <section class="tutorial-section">
            <h2>Understanding the Data Flow</h2>
            <ol>
                <li><strong>Stimuli Extraction</strong>: Text is processed into features (embeddings, word rates, etc.)</li>
                <li><strong>Timing Alignment</strong>: Features are aligned with brain data using timing information</li>
                <li><strong>Downsampling</strong>: High-resolution features are downsampled to match brain data TR</li>
                <li><strong>FIR Delays</strong>: Temporal delays are applied to account for hemodynamic response</li>
                <li><strong>Train/Test Split</strong>: Data is split for proper evaluation</li>
            </ol>
        </section>

        <section class="tutorial-section">
            <h2>Assembly Attributes</h2>
            <p>An assembly has several key attributes:</p>
            <p><strong>Shape</strong>: (n_presentations, n_voxels/vertices)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Total number of timepoints and brain regions</p>
            <p><strong>Stories</strong>: List of story names<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Each story represents a continuous experimental session</p>
            <p><strong>Story Data</strong>: Dictionary of story-specific data<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Contains all the data for each story</p>
            <p><strong>Coordinates</strong>: Metadata about presentations<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Story IDs, stimulus IDs, etc.</p>
            <p><strong>Validation Method</strong>: "inner" or "outer"<br>
            &nbsp;&nbsp;&nbsp;&nbsp;How the assembly handles train/test splits</p>
        </section>

        <section class="tutorial-section">
            <h2>Working with Story Data</h2>
            <p>Each story in an assembly contains:</p>
            <pre class="code-block"><code class="language-python"># Get data for a specific story
story_name = assembly.stories[0]
story_data = assembly.story_data[story_name]

print(f"Story: {story_name}")
print(f"  Brain data: {story_data.brain_data.shape}")
print(f"  Stimuli: {len(story_data.stimuli)}")
print(f"  Split indices: {len(story_data.split_indices)}")
print(f"  TR times: {len(story_data.tr_times)}")
print(f"  Data times: {len(story_data.data_times)}")

# Access specific data
brain_data = story_data.brain_data
stimuli = story_data.stimuli
split_indices = story_data.split_indices
tr_times = story_data.tr_times
data_times = story_data.data_times</code></pre>
        </section>

        <section class="tutorial-section">
            <h2>Using Assemblies in Training</h2>
            <p>Here's how assemblies are used in the training pipeline:</p>
            <pre class="code-block"><code class="language-python">from encoding.assembly.assembly_loader import load_assembly
from encoding.features.factory import FeatureExtractorFactory
from encoding.downsample.downsampling import Downsampler
from encoding.models.nested_cv import NestedCVModel
from encoding.trainer import AbstractTrainer

# 1. Load assembly
assembly = load_assembly("assembly_lebel_uts03.pkl")

# 2. Create feature extractor
extractor = FeatureExtractorFactory.create_extractor(
    modality="wordrate",
    model_name="wordrate",
    config={},
    cache_dir="cache",
)

# 3. Set up other components
downsampler = Downsampler()
model = NestedCVModel(model_name="ridge_regression")

# 4. Configure training parameters
fir_delays = [1, 2, 3, 4]
trimming_config = {
    "train_features_start": 10,
    "train_features_end": -5,
    "train_targets_start": 0,
    "train_targets_end": None,
    "test_features_start": 50,
    "test_features_end": -5,
    "test_targets_start": 40,
    "test_targets_end": None,
}

# 5. Create trainer
trainer = AbstractTrainer(
    assembly=assembly,
    feature_extractors=[extractor],
    downsampler=downsampler,
    model=model,
    fir_delays=fir_delays,
    trimming_config=trimming_config,
    use_train_test_split=True,
    logger_backend="wandb",
    wandb_project_name="lebel-tutorial",
    dataset_type="lebel",
    results_dir="results",
)

# 6. Train the model
metrics = trainer.train()
print(f"Median correlation: {metrics.get('median_score', float('nan')):.4f}")</code></pre>
        </section>

        <section class="tutorial-section">
            <p>This understanding of assemblies is crucial for effectively using LITcoder. The assembly serves as the foundation for all encoding model training, providing the structured interface between your experimental data and the machine learning pipeline.</p>
        </section>

        <footer class="footer">
            <div>© 2025 LITCoder Project — Georgia Tech</div>
            <div style="font-size: 0.8rem; margin-top: 4px;">Authors: Taha Binhuraib, Ruimin Gao, Anna A. Ivanova</div>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 